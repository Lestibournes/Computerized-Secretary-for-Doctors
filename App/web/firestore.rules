rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    match /{document=**} {
			// Only for development purposes:
			allow read, write: if true;
    }

		function isLoggedIn() {
			return request.auth != null;
		}

		function isRoot() {
			return request.auth.uid == get(/databases/$(database)/documents/administration/roles).data.root;
		}

		function isAdministrator() {
			return request.auth.uid in get(/databases/$(database)/documents/administration/roles).data.administrators;
		}

		match /users/{userID} {
			// People who should be allowed to read the data: the user, any employee of a clinic where he had an appointment, any doctor he visited.
			// Perhaps let anyone see name and sex, but date of birth, number of siblings, or other sensitive data will be stored in {userID}/private/personal and can only be viewed by the doctor.
			allow read: if request.auth != null;

			// People who should be allowed to edit the data: just the user.
			function isTheUser() {
				return request.auth.uid == userID;
			}

			function isOneOfTheDoctors() {
				return exists(/databases/$(database)/documents/users/$(userID)/private/doctors/$(request.auth.uid));
			}
			
			function isValidData() {
				return
				request.resource.data.firstName is string &&
				request.resource.data.firstName.size() > 1 &&
				request.resource.data.firstName.size() < 200 &&
				request.resource.data.sex is string &&
				request.resource.data.sex in ["male", "female"];
			}

			allow create, update: if isTheUser() && isValidData();

			match /private/personal {
				function isValidData() {
					return
					request.resource.data.birthday is timestamp &&
					request.resource.data.birthday < request.time &&
					request.resource.data.siblings is number &&
					request.resource.data.siblings >= 0;
				}

				allow read: if isTheUser() || isOneOfTheDoctors();
				allow write: if isTheUser() && isValidData();

				
				match /doctors {
					// Stores the collection of all the doctors that the user has appointments with, past and future.
					// I suppose it will need to be maintained by a Cloud Functions effect.
					allow read: if isTheUser()
					allow write: if false; // Since this is automatically maintained by the server.
				}

				match /specializations/{specID} {
					// The id is the name of the specialization.
					// This is so that multiple doctors can share the same specialization without being restricted to a central list.
					// Perhaps the properties can include translations? Or should the translations be provided in the specialization collection?
					function isValidData() {
						return
						request.resource.id is string &&
						request.resource.id.size() > 1 &&
						request.resource.id.size() < 50
					}

					allow read;
					allow write: if isTheUser() && isValidData();
				}
			}
		}

		match /clinics/{clinicID} {
			function isOwner() {
				return resource.data.owner == request.auth.uid;
			}

			function isSecretary() {
				return exists(/databases/$(database)/documents/clinics/$(clinicID)/secretaries/$(request.auth.uid));
			}

			function isPatient(appointmentID) {
				return get(/databases/$(database)/documents/clinics/$(clinicID)/appointments/$(appointmentID)).data.patient == request.auth.uid;
			}

			function isTheDoctor(appointmentID) {
				return get(/databases/$(database)/documents/clinics/$(clinicID)/appointments/$(appointmentID)).data.doctor == request.auth.uid;
			}

			function isValidData() {
				return
				// The name of the clinic must be of a short string:
				request.resource.data.name is string &&
				request.resource.data.name.size() >= 1 &&
				request.resource.data.name.size() <= 50  &&
				
				// The city where the clinic is located must be a short string:
				request.resource.data.city is string &&
				request.resource.data.city.size() >= 1 &&
				request.resource.data.city.size() <= 50  &&
				
				// The city where the clinic is located must be a short string:
				request.resource.data.address is string &&
				request.resource.data.address.size() >= 1 &&
				request.resource.data.address.size() <= 50 &&
				
				request.resource.data.language is string &&
				exists(/databases/$(database)/documents/languages/$(request.resource.data.language));
			}

			allow read: if isLoggedIn();
			allow create: if isOwner() && isValidData();
			allow update: if 
				isOwner() &&
				isValidData() &&
				// If the owner isn't changed:
				resource.data.owner == request.resource.data.owner;
			allow delete: if isOwner();

			match /appointments/{appointmentID} {
			// Store all the appointments only as subcollections of the clinics.
			// This then allows to easily check if the user is a secretary of the clinic.
			// In order to fetch all of a user's or doctor's appointments across all clinics, use collectionGroup:
			// collectionGroup("appointments").where("doctor", "==", doctor)
			// collectionGroup("appointments").where("patient", "==", patient)
			// Secretaries only need to access the appointments of one clinic at a time.
			// To retrieve all appointments of a patient/doctor at one specific a clinic, use:
			// collection("clinics").doc(clinic).collection("appointments").where("doctor", "==", doctor)
			// collection("clinics").doc(clinic).collection("appointments").where("patient", "==", patient)
			// There is still the issue of what to do regarding the doctor's meeting notes.
			// Perhaps the patient should be able to read them, but not write them.

				// Even though writing the data (create, update) is entirely up to Cloud Functions I still want to specify the requirements.
				function isValidData() {
					return
					// The patient is an existing user in the system:
					exists(/databases/$(database)/documents/users/$(request.resource.data.patient)) &&
					// The doctor is registered as a doctor in the system: (Should this just be a field in the user document? Since I'm already checking if the doctor works in the clinic as a doctor, do I need to perform this check at all?)
					exists(/databases/$(database)/documents/doctors/$(request.resource.data.doctor)) &&
					// The patient and doctor are different people:
					get(/databases/$(database)/documents/clinics/$(clinicID)/appointments/$(request.resource.data.appointment)).data.doctor != get(/databases/$(database)/documents/clinics/$(clinicID)/appointments/$(request.resource.data.appointment)).data.patient &&
					// The clinic exists in the system:(is clinic even needed as a field?)
					exists(/databases/$(database)/documents/clinics/$(request.resource.data.clinic)) &&
					// The doctor works for the clinic:
					exists(/databases/$(database)/documents/clinics/$(clinicID)/doctors/$(request.resource.data.doctor)) &&
					// The start time of the appointment is in the future:
					request.resource.data.start is timestamp &&
					request.resource.data.start > request.time &&
					// The end time of the appointment is after the start time:
					request.resource.data.end is timestamp &&
					request.resource.data.end > request.resource.data.start &&
					// The doctor offers the requested appointment type:
					request.resource.data.type is string &&
					request.resource.data.type in get(/databases/$(database)/documents/clinics/$(clinicID)/doctors/$(request.resource.data.doctor)).data.types &&
					// The duration of the appointment matches the appointment type's duration:
					request.resource.data.end - request.resource.data.start == get(/databases/$(database)/documents/clinics/$(clinicID)/doctors/$(request.resource.data.doctor)).data.types[request.resource.data.type].duration * get(/databases/$(database)/documents/clinics/$(clinicID)/doctors/$(request.resource.data.doctor)).data.minimum
				}

				allow read: if isPatient(appointmentID) || isTheDoctor(appointmentID) || isSecretary();
				allow delete: if
					(isPatient(appointmentID) || isTheDoctor(appointmentID) || isSecretary()) &&
					get(/databases/$(database)/documents/clinics/$(clinicID)/appointments/$(appointmentID)).data.start > request.time; //Appointments can only be deleted if they haven't occured yet.

				// Since the appointment time slot must not collide with other appointments,
				// and since I don't think that that can be checked through security rules,
				// then I will disallow creating new appointments to force new appointments to be created through Cloud Functions.
				// Update could be allowed if it didn't change the start or end time,
				// but that's basically the whole data, so what's the point?
				// Also changing clinics, doctors, or patients should be prohibited.
				// Therefor the only thing that update could change is appointment type,
				// and only on the condition that the appointment duration stays the same.
				allow create, update: if false && isValidData();

				match /messages/{messageID} {
					// If I want to enforce correct timestamps on messages
					// (which probably isn't necessary since it's just communication between the doctor and patient)
					// then I can either pass message creation through a Cloud Function or (better yet?)
					// use a Cloud Function effect to add a timestamp to each new message as it comes in.
					// The downside of using an effect is that with live updates the other user will receive the new message before it has a timestamp,
					// but I guess with live listening including the existing messages the timestamp will be loaded a moment later anyway.

					// Turns out that there is a way to validate the time, which looks like this: request.resource.data.timestamp == request.time
					function isSender() {
						return request.resource.data.sender == request.auth.uid;
					}

					function isValidData() {
						return
						// The sender is either the doctor or patient of this appointment:
						(request.resource.data.sender == get(/databases/$(database)/documents/clinics/$(clinicID)/appointments/$(appointmentID)).data.doctor ||
						request.resource.data.sender == get(/databases/$(database)/documents/clinics/$(clinicID)/appointments/$(appointmentID)).data.patient) &&
						request.resource.data.text is string &&
						request.resource.data.text.size() > 1 &&
						request.resource.data.text.size() < 2000 &&
						request.resource.data.timestamp == request.time;
					}

					allow read: if isPatient(appointmentID) || isTheDoctor(appointmentID);
					allow create: if isSender() && isValidData();
				}
			}

			// Notes that the doctor writes about the meeting.
			// The noteID should be the same as the appointmentID for easy fetching.
			// The notes collection is kept directly beneath the clinic document so that doctors will be able to view all of their own notes using collectionGroup.
			match /notes/{noteID} {
				function isValidData() {
					return
					request.resource.data.doctor == request.auth.uid &&
					request.resource.data.patient is string &&
					exists(/databases/$(database)/documents/users/$(request.resource.data.patient)) &&
					request.resource.data.text is string
				}

				allow read: if isPatient(noteID) || isTheDoctor(noteID);
				allow write: if isTheDoctor(noteID) && isValidData();
			}

			// The patient's arrival status. This is an internal piece of data for the clinic that the patient doesn't need access to.
			// The arrivalID should be the same as the appointmentID for easy fetching.
			// This is directly beneath the clinic document so that the doctors can receive arrival notifications through listening to the collectionGroup.
			match /arrivals/{arrivalID} {
				function isValidData() {
					return
					exists(/databases/$(database)/documents/clinics/$(clinicID)/appointments/$(arrivalID)) &&
					exists(/databases/$(database)/documents/clinics/$(clinicID)/appointments/$(arrivalID)).data.start > request.time &&
					request.resource.data.arrived is bool;
				}

				allow read: if isTheDoctor(arrivalID) || isSecretary();
				allow write: if (isTheDoctor(arrivalID) || isSecretary()) && isValidData();

				// For deletion of the appointment by the patient, use a Cloud Functions event handler (effect?).
			}
		}

		match /cities/{cityID} {
			// The cityID is the name of the city.
			// This is readable by all but writable by none as it's an automatically maintained index of all the cities that have clinics.
			// Each city document has a collection of clinics that are located in it.
			// Actually this is not needed since it's only useful for search, and search has been scrapped.
			// Perhaps something like this could be used for providing translations of city names?

			allow read;
			allow write: if false;

			match /clinics/{clinicID} {
				// This is an automatically-maintained collection of all the clinics in the city.

				// This function isn't used, but I want to specify the requirements anyway:
				function isValidData() {
					return
					request.resource.data.exists == true &&
					exists(/databases/$(database)/documents/clinics/$(clinicID));
				}

				allow read;
				allow write: if false && isValidData();
			}
		}

		match /specializations/{specializationID} {
			// This is readable by all but writable by none as it's an automatically maintained index of all the specializations that doctors have.
			// Each specialization document has a collection of doctors that have it.
			// Actually this is not needed since it's only useful for search, and search has been scrapped.
			// Perhaps something like this could be used for providing translations of specialization names?

			// This function isn't used, but I want to specify the requirements anyway:
			function isValidData() {
				return
					request.resource.data.name is string &&
					request.resource.data.name.size() >= 1 &&
					request.resource.data.name.size() <= 50
			}

			allow read;
			allow write: if false && isValidData();


			match /doctors/{doctorID} {
				// This is an automatically-maintained collection of all the doctors who have this specialization.

				// This function isn't used, but I want to specify the requirements anyway:
				function isValidData() {
					return
					request.resource.data.exists == true &&
					exists(/databases/$(database)/documents/users/$(doctorID)) &&
					get(/databases/$(database)/documents/users/$(doctorID)).data.doctor == true;
				}

				allow read;
				allow write: if false && isValidData();
			}
		}

		match /languages/{languageID} {
			// Stores the system UI strings for different languages.
			// The default display language should be chosen by user locale data.
			// Users can override the default and manually select their own preffered language.
			// What about translations for the user-provided data, like doctor/user names, clinic names, cities, addresses, specializations, and appointment types?
			// Perhaps each of these objects should have a map for such strings, and the user will be able to provide the translations/translitterations in the supported languages.

			// Each language document should contain:
			// Language name
			// Language code, which can also be used to identify the icon
			// Icon link or other such thing, if I use and external resource for the icon
			// A complete map mapping UI strings in the reference language (English) to their counterparts in this language.
			// I will need a way to mark variables in the translation string so that the variables in the source string can be plugged in.
			function isValidData() {
				return
				request.resource.data.name is string &&
				request.resource.data.name.size() >= 1 &&
				request.resource.data.name.size() <= 20 &&
				request.resource.data.code is string &&
				request.resource.data.code.size() == 2 &&
				request.resource.data.strings is map;
			}

			allow read;
			allow write: if isAdministrator() && isValidData();
		}

		match /administration/roles {
			// This document holds maps of users with different administrative roles in the app.
			// There are basically 2 roles:
			// root, which is a single user that has the highest level of privilege.
			// administrators, which are many, and hold all administrative privileges aside from modifying roles.

			function isValidData() {
				return 
				exists(/databases/$(database)/documents/users/$(request.resource.data.root)) &&
				request.resource.data.administrators is map &&
				request.resource.data.root in request.resource.data.administrators;
			}

			allow read: if isAdministrator() || isRoot();
			allow create, update: if isRoot() && isValidData();
			allow delete: if false; // Explicitly stating that delete should never be allowed.
		}

		match /links/{linkID} {
			// The id of the link is the link string itself.
			
			function isOwner() {
				return
				(request.resource.data.type == "clinic" &&
				get(/databases/$(database)/documents/clinics/$(request.resource.data.id)).data.owner == request.auth.uid)
				||
				(request.resource.data.type == "doctor" &&
				request.resource.data.id == request.auth.uid);
			}

			function isValidData() {
				return
				(request.resource.data.type == "clinic" &&
				exists(/databases/$(database)/documents/clinics/$(request.resource.data.id))) ||
				(request.resource.data.type == "doctor" &&
				exists(/databases/$(database)/documents/doctors/$(request.resource.data.id))) &&
				request.resource.id.matches('^[a-zA-Z0-9_]+$');
			}

			allow read;
			allow write: if isOwner() && isValidData();
		}
  }
}